<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="学号293 原创作品 转载请注明出处">
<meta property="og:type" content="article">
<meta property="og:title" content="实验三从整理上理解进程创建、可执行文件的加载和进程执行进程切换，重点理解分析fork、execve和进程切换">
<meta property="og:url" content="http://yoursite.com/2019/05/16/实验三-从整理上理解进程创建、可执行文件的加载和进程执行进程切换，重点理解分析fork、execve和进程切换/index.html">
<meta property="og:site_name" content="Everthing will be OK!">
<meta property="og:description" content="学号293 原创作品 转载请注明出处">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1510236/201903/1510236-20190326201014169-1471370366.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190326150104622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqejAwMA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1510236/201903/1510236-20190326215140213-1784521822.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1510236/201903/1510236-20190326215249160-400368726.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1510236/201903/1510236-20190326215422135-678338522.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1510236/201903/1510236-20190326215518490-1402478397.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1510236/201903/1510236-20190326215548044-1583884073.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190322191439317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190322191941319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1510236/201903/1510236-20190326221155039-1722522330.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190322201111879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190322201226181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190322201310406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190322211251630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190322211545516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190322211616457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190322211725727.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190322211754470.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190322211833992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2019-05-15T17:58:51.861Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="实验三从整理上理解进程创建、可执行文件的加载和进程执行进程切换，重点理解分析fork、execve和进程切换">
<meta name="twitter:description" content="学号293 原创作品 转载请注明出处">
<meta name="twitter:image" content="https://img2018.cnblogs.com/blog/1510236/201903/1510236-20190326201014169-1471370366.png">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/05/16/实验三-从整理上理解进程创建、可执行文件的加载和进程执行进程切换，重点理解分析fork、execve和进程切换/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>实验三从整理上理解进程创建、可执行文件的加载和进程执行进程切换，重点理解分析fork、execve和进程切换 | Everthing will be OK!</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Everthing will be OK!</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">可以毕业但没必要--来自没有offer的pcm</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/16/实验三-从整理上理解进程创建、可执行文件的加载和进程执行进程切换，重点理解分析fork、execve和进程切换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="PCM">
      <meta itemprop="description" content="fighting">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Everthing will be OK!">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">实验三从整理上理解进程创建、可执行文件的加载和进程执行进程切换，重点理解分析fork、execve和进程切换

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-16 01:16:40 / 修改时间：01:58:51" itemprop="dateCreated datePublished" datetime="2019-05-16T01:16:40+08:00">2019-05-16</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>学号293 原创作品 <a href="https://github.com/mengning/linuxkernel/" target="_blank" rel="noopener">转载请注明出处</a></p>
<a id="more"></a>



<p><img src="https://img2018.cnblogs.com/blog/1510236/201903/1510236-20190326201014169-1471370366.png" alt></p>
<h2 id="一、阅读理解task-struct数据结构"><a href="#一、阅读理解task-struct数据结构" class="headerlink" title="一、阅读理解task_struct数据结构"></a>一、阅读理解task_struct数据结构</h2><p><a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/include/linux/sched.h#1235%EF%BC%9B" target="_blank" rel="noopener">代码地址</a></p>
<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul>
<li><p>进程是程序的一个执行实例</p>
</li>
<li><p>进程是正在执行的程序</p>
</li>
<li><p>进程是能分配处理器并由处理器执行的实体</p>
<p>系统为了管理进程需要对每个进程所做的事情进行描述。一般，操作系统使用数据结构来代表不同的实体，这个数据结构就是通常所说的进程控制块PCB。在linux中即是task_struct。结构定义位于</p>
</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/include/linux/sched.h</span><br></pre></td></tr></table></figure>

<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul>
<li>进程管理</li>
<li>内存管理</li>
<li>文件系统</li>
</ul>
<h4 id="进程控制块PCB–task-struct"><a href="#进程控制块PCB–task-struct" class="headerlink" title="进程控制块PCB–task_struct"></a>进程控制块PCB–task_struct</h4><ul>
<li>进程在TASK_RUNNING下是可运行的，但它有没有运行取决于它有没有获得cpu的控制权，即这个进程有没有在cpu上实际的执行</li>
<li>进程的标示pid</li>
<li>程序创建的进程具有父子关系，在编程时往往需要引用这样的父子关系。进程描述符中有几个域用来表示这样的关系</li>
</ul>
<h4 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> state;<span class="comment">//表示进程的当前状态: </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags; <span class="comment">//进程标志: </span></span><br><span class="line"><span class="keyword">long</span> priority; <span class="comment">//进程优先级。 Priority的值给出进程每次获取CPU后可使用的时间(按jiffies计)。优先级可通过系统调用sys_setpriorty改变(在kernel/sys.c中)。 </span></span><br><span class="line"><span class="keyword">long</span> counter; <span class="comment">//在轮转法调度时表示进程当前还可运行多久。 </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> policy; <span class="comment">//该进程的进程调度策略，可以通过系统调用sys_sched_setscheduler()更改(见kernel/sched.c)。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190326150104622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqejAwMA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​    进程描述符中有指向mm_struct结构体的指针mm，这个结构体是对该进程用户空间的描述；也有指向fs_struct结构体的指针fs，这个结构体是对进程当前所在目录的描述；也有指向files_struct结构体的指针files，这个结构体是对该进程已打开的所有文件进行描述；另外还有一个小型的进程描述符(low-level information)—thread_info。在这个结构体中，也有指向该进程描述符的指针task。因此，这两个结构体是相互关联的。</p>
<h2 id="二、分析fork函数对应的内核处理过程"><a href="#二、分析fork函数对应的内核处理过程" class="headerlink" title="二、分析ｆｏｒｋ函数对应的内核处理过程"></a>二、分析ｆｏｒｋ函数对应的内核处理过程</h2><p>fork、vfork、 clone三个系统调用都可以创建一个新进程，而且都是通过调用do_fork来实现进程的创建。</p>
<p>具体过程如下: fork() -&gt; sys_clone() -&gt; do_fork() -&gt; dup_task_struct() -&gt; copy_process() -&gt; copy_thread() -&gt; ret_from_fork()</p>
<p>分析do_fork代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> __user *parent_tidptr,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> __user *child_tidptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> trace = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> nr;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 复制进程描述符，返回创建的task_struct的指针</span></span><br><span class="line">    p = copy_process(clone_flags, stack_start, stack_size,</span><br><span class="line">             child_tidptr, <span class="literal">NULL</span>, trace);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(p)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">vfork</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line"> </span><br><span class="line">        trace_sched_process_fork(current, p);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 取出task结构体内的pid</span></span><br><span class="line">        pid = get_task_pid(p, PIDTYPE_PID);</span><br><span class="line">        nr = pid_vnr(pid);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line">            put_user(nr, parent_tidptr);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果使用的是vfork，那么必须采用某种完成机制，确保父进程后运行</span></span><br><span class="line">        <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">            p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">            init_completion(&amp;vfork);</span><br><span class="line">            get_task_struct(p);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将子进程添加到调度器的队列，使得子进程有机会获得CPU</span></span><br><span class="line">        wake_up_new_task(p);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果设置了 CLONE_VFORK 则将父进程插入等待队列，并挂起父进程直到子进程释放自己的内存空间</span></span><br><span class="line">        <span class="comment">// 保证子进程优先于父进程运行</span></span><br><span class="line">        <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!wait_for_vfork_done(p, &amp;vfork))</span><br><span class="line">                ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        put_pid(pid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nr = PTR_ERR(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do_fork中调用copy_process，将当期进程复制一份出来为子进程，并且为子进程设置相应地上下文信息。<br>初始化vfork的完成处理信息（如果是vfork调用）<br>调用wake_up_new_task，将子进程放入调度器的队列中，此时的子进程就可以被调度进程选中，得以运行。如果是vfork调用，需要阻塞父进程，知道子进程执行exec。</p>
<p>当执行fork系统调用时，操作系统会执行以下步骤: </p>
<p>1.内核确保有创建新进程所需的充足的系统资源。其完成过程如下:</p>
<p>（1）内核确保系统可以处理多个将要调度的进程，而且调度程序上的负载是可以管理的。</p>
<p>（2）内核确保这个特定的用户当前没有运行过多垄断使用现有资源的进程。</p>
<p>（3）内核确保为新进程提供足够的内存空间。<br>操作系统已经知道：此时新进程和父进程在各个方面都是相同的。这还包括内存要求。在交换系统中，整个内存都要是可用的。在纯分页系统中，需要大量用于保存整个地址空间和页面映射表的内存空间。在请求分页调度中，启动进程，至少页面映射表必不可少。在请求分页调度方法中，地址空间中更多的页面可以通过缺页错误累计得到。如果内存空间不足，内核检查磁盘上是否有空间，如果有，就占用该空间的交换区。像前面在进程状态转移中讨论的一样，据此确定子进程的状态。</p>
<p>2.内核现在从进程表中找到一个位置，然后开始构造子进程的上下文。</p>
<p>3.内核维护”下一个可用的ID号”的全局值。任何时候，当fork系统调用创建新进程时，内核将该ID分配给新的子进程，并将该编号加1。内核还要设置一个最大值，当设置超过这个值的时候，系统就不能处理任何进程。如果该编号等于或大于这个最大值，内核从0重新分配编号，但是另一方面希望pid等于0的进程已经终止运行。</p>
<p>4.内核初始化子进程的进程表插槽中的字段，如下：</p>
<p>（1） 内核将真实有效的用户ID从父进程的进程表插槽中复制到子进程对应的位置。</p>
<p>（2）内核还要将父进程的准确值复制给子进程。</p>
<p>（3）内核通过将父进程ID复制到子进程插槽，从而链接进程树结构中的子进程。</p>
<p>（4）内核初始化子进程插槽中不同的调度字段和统计字段，如初始优先级、CPU使用情况等。</p>
<p>（5）内核将该子进程的状态设置为”正在创建”。</p>
<p>5.现在，内核搜索父进程u区（进程信息交换区）中的文件描述符，并沿着指针从用户打开文件描述符到文件表条目，同时将文件表中那些条目的引用计数增加1。</p>
<p>6.内核为子进程的u区、区域表、页表等分配内存空间。</p>
<p>7.现在，除了子进程u区指向进程表插槽的指针要做适当的调整之外，内核将父进程的u区复制给子进程。这是因为父进程和子进程在进程表中有两个不同的条目。因此，指向这两个不同条目的指针也不相同。此时，所有其他内容是相同的。</p>
<p>8.内核将数据和堆栈区(非共享的部分)复制到子进程的另一个内存区，并调整区域表条目。然而，它只保存文本区的一个副本，因为文本区是共享的。诚如所示，此时文本包含相同的程序代码。</p>
<p>9.内核在子进程上下文的静态部分后面创建动态内容。它复制父进程上下文包含保存Fork系统调用的寄存器和内核堆栈的第一层。此时，父进程和子进程的内核堆栈的内容完全相同。</p>
<p>10/内核创建子进程第2层的伪程序上下文，这个伪程序上下文包括第1层保存的寄存器上下文。它在寄存器内容保存区中设置程序计数器(PC)和其他寄存器，这样就可以在适当的位置”重新开始”执行子进程。</p>
<p>11.现在，内核将子进程状态从”准备就绪”变成”准备运行”(根据情况要么在内存中，要么被交换)。它将子进程ID返回给用户。</p>
<p>12.调度程序最终调度子进程。在程序中，调度程序检查它是不是子进程。因为如果是子进程，它会执行”Exec”系统调用，由此将新程序加载到子进程的地址空间中。</p>
<p>3.1 do_fork()流程</p>
<pre><code>首先调用copy_process()为子进程复制出一份进程信息，如果是vfork()则初始化完成处理信息；
然后调用wake_up_new_task将子进程加入调度器，为之分配CPU，如果是vfork()，则父进程等待子进程完成exec替换自己的地址空间。</code></pre><p>3.2 copy_process()流程</p>
<pre><code>首先调用dup_task_struct()复制当前的task_struct，检查进程数是否超过限制；
接着初始化自旋锁、挂起信号、CPU 定时器等；
然后调用sched_fork初始化进程数据结构，并把进程状态设置为TASK_RUNNING，复制所有进程信息，包括文件系统、信号处理函数、信号、内存管理等；
调用copy_thread()初始化子进程内核栈，为新进程分配并设置新的pid。</code></pre><p>3.3 dup_task_struct()流程</p>
<pre><code>调用alloc_task_struct_node()分配一个 task_struct 节点；
调用alloc_thread_info_node()分配一个 thread_info 节点，其实是分配了一个thread_union联合体,将栈底返回给 ti；
最后将栈底的值 ti 赋值给新节点的栈。</code></pre><p>3.4 copy_thread的流程</p>
<pre><code>获取子进程寄存器信息的存放位置
对子进程的thread.sp赋值，将来子进程运行，这就是子进程的esp寄存器的值。
如果是创建内核线程，那么它的运行位置是ret_from_kernel_thread，将这段代码的地址赋给thread.ip，之后准备其他寄存器信息，退出
将父进程的寄存器信息复制给子进程。
将子进程的eax寄存器值设置为0，所以fork调用在子进程中的返回值为0.
子进程从ret_from_fork开始执行，所以它的地址赋给thread.ip，也就是将来的eip寄存器。</code></pre><p>3.5 新进程从ret_from_fork处开始执行，子进程的运行是由这几处保证的</p>
<pre><code>dup_task_struct中为其分配了新的堆栈
copy_process中调用了sched_fork，将其置为TASK_RUNNING
copy_thread中将父进程的寄存器上下文复制给子进程，这是非常关键的一步，这里保证了父子进程的堆栈信息是一致的。
将ret_from_fork的地址设置为eip寄存器的值，这是子进程的第一条指令。</code></pre><h3 id="三-使用GDB分析"><a href="#三-使用GDB分析" class="headerlink" title="三.使用GDB分析"></a>三.使用GDB分析</h3><p> 在test.c中添加使用fork系统函数的调用</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int testFork(int argc, char *argv[])&#123;</span><br><span class="line">     pid_t fpid; </span><br><span class="line">     int count=<span class="number">0</span>;  </span><br><span class="line">     fpid=fork();   </span><br><span class="line">     <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>)   </span><br><span class="line">         printf("error <span class="keyword">in</span> fork!");   </span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;  </span><br><span class="line">         printf("i am the child process, my process id is %d\n",getpid());        </span><br><span class="line">         count++;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">else</span> &#123;  </span><br><span class="line">         printf("i am the parent process, my process id is %d\n",getpid());   </span><br><span class="line">         count++;  </span><br><span class="line">     &#125;  </span><br><span class="line">     printf("result: %d\n",count);  </span><br><span class="line">     return <span class="number">0</span>;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>添加到menuconfig中</p>
<p>然后重新生成文件系统，使用qemu重新挂载内核，然后(承接上次)</p>
<p><code>make rootfs</code></p>
<p>然后重开一个shell进入linux内核的文件夹进行gdb。</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gdb vmlinux</span><br><span class="line">target remote:<span class="number">1234</span></span><br><span class="line">b sys_clone</span><br><span class="line">b do_fork</span><br><span class="line">b dup_task_struct</span><br><span class="line">b copy_process</span><br><span class="line">b copy_thread</span><br><span class="line">b ret_from_for</span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1510236/201903/1510236-20190326215140213-1784521822.png" alt></p>
<p><img src="https://img2018.cnblogs.com/blog/1510236/201903/1510236-20190326215249160-400368726.png" alt></p>
<p><img src="https://img2018.cnblogs.com/blog/1510236/201903/1510236-20190326215422135-678338522.png" alt></p>
<p><img src="https://img2018.cnblogs.com/blog/1510236/201903/1510236-20190326215518490-1402478397.png" alt></p>
<p><img src="https://img2018.cnblogs.com/blog/1510236/201903/1510236-20190326215548044-1583884073.png" alt></p>
<h3 id="四、理解编译连接的过程和ELF可执行文件格式"><a href="#四、理解编译连接的过程和ELF可执行文件格式" class="headerlink" title="四、理解编译连接的过程和ELF可执行文件格式"></a>四、理解编译连接的过程和ELF可执行文件格式</h3><p><img src="https://img-blog.csdnimg.cn/20190322191439317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>Elf可执行文件的过程</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个可重定位(relocatable)文件保存着代码和适当的数据，用来和其他的object文件一起来创建一个可执行文件或者是一个共享文件。 </span><br><span class="line">一个可执行(executable)文件保存着一个用来执行的程序；该文件指出了exec(BA_OS)如何来创建程序进程映象。 </span><br><span class="line">一个共享object文件保存着代码和合适的数据，用来被不同的两个链接器链接。</span><br></pre></td></tr></table></figure>

<p>流程图</p>
<p><img src="https://img-blog.csdnimg.cn/20190322191941319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="五、编程使用exec-库函数加载一个可执行文件，动态链接分为可执行程序装载时动态链接和运行时动态链接"><a href="#五、编程使用exec-库函数加载一个可执行文件，动态链接分为可执行程序装载时动态链接和运行时动态链接" class="headerlink" title="五、编程使用exec*库函数加载一个可执行文件，动态链接分为可执行程序装载时动态链接和运行时动态链接"></a>五、编程使用exec*库函数加载一个可执行文件，动态链接分为可执行程序装载时动态链接和运行时动态链接</h3><p>编辑一个test.c文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后进行编译</p>
<p><img src="https://img2018.cnblogs.com/blog/1510236/201903/1510236-20190326221155039-1722522330.png" alt></p>
<p>test.static 明显大于test。</p>
<p>静态链接方式：在程序运行之前完成所有的组装工作，生成一个可执行的目标文件</p>
<p>动态链接方式：在程序已经为了执行被装载入内存之后完成链接工作，并且在内存中一般只保留该编译单元的一份拷贝</p>
<p>动态链接库的两种链接方式:装载时动态链接、运行时动态链接</p>
<h3 id="六、使用gdb跟踪分析一个execve系统调用内核处理函数do-execve-验证您对linux系统加载可执行程序所需过程的理解"><a href="#六、使用gdb跟踪分析一个execve系统调用内核处理函数do-execve-验证您对linux系统加载可执行程序所需过程的理解" class="headerlink" title="六、使用gdb跟踪分析一个execve系统调用内核处理函数do_execve,验证您对linux系统加载可执行程序所需过程的理解"></a>六、使用gdb跟踪分析一个execve系统调用内核处理函数do_execve,验证您对linux系统加载可执行程序所需过程的理解</h3><p>1.设置断点<br><img src="https://img-blog.csdnimg.cn/20190322201111879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.中断情况如下<br><img src="https://img-blog.csdnimg.cn/20190322201226181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20190322201310406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>do_execve</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_execve</span><span class="params">(struct filename *filename, </span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *__argv,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *__envp)</span> </span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_arg_ptr</span> <span class="title">argv</span> = &#123;</span> .ptr.native = __argv &#125;; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_arg_ptr</span> <span class="title">envp</span> = &#123;</span> .ptr.native = __envp &#125;; </span><br><span class="line">    <span class="comment">//调用do_execve_common </span></span><br><span class="line">    <span class="keyword">return</span> do_execve_common(filename, argv, envp); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、特别关注新的可执行程序是从哪里开始执行的？为什么execve系统调用返回后新的可执行程序能顺利执行？对于静态链接的可执行程序和动态链接的可执行程序execve系统调用返回时会有什么不同？"><a href="#七、特别关注新的可执行程序是从哪里开始执行的？为什么execve系统调用返回后新的可执行程序能顺利执行？对于静态链接的可执行程序和动态链接的可执行程序execve系统调用返回时会有什么不同？" class="headerlink" title="七、特别关注新的可执行程序是从哪里开始执行的？为什么execve系统调用返回后新的可执行程序能顺利执行？对于静态链接的可执行程序和动态链接的可执行程序execve系统调用返回时会有什么不同？"></a>七、特别关注新的可执行程序是从哪里开始执行的？为什么execve系统调用返回后新的可执行程序能顺利执行？对于静态链接的可执行程序和动态链接的可执行程序execve系统调用返回时会有什么不同？</h3><p>新的可执行程序通过修改内核堆栈eip作为新程序的起点，<br>从new_ip开始执行后start_thread把返回到用户态的位置从int 0x80的下一条指令变成新加载的可执行文件的入口位置。</p>
<ul>
<li>当执行到execve系统调用时，进入内核态，用execve()加载的可执行文件覆盖当前进程的可执行程序，</li>
</ul>
<p>当execve系统调用返回时，返回新的可执行程序的执行起点（main函数），所以execve系统调用返回后新的可执行程序能顺利执行。</p>
<ul>
<li>execve系统调用返回时，如果是静态链接，elf_entry指向可执行文件规定的头部（main函数对应的位置0x8048***）；如果需要依赖动态链接库，elf_entry指向动态链接器的起点。动态链接主要是由动态链接器ld来完成的。</li>
</ul>
<h3 id="八、理解Linux系统中进程调度的时机，可以在内核代码中搜索schedule-函数，看都是哪里调用了schedule-，判断我们课程内容中的总结是否准确；"><a href="#八、理解Linux系统中进程调度的时机，可以在内核代码中搜索schedule-函数，看都是哪里调用了schedule-，判断我们课程内容中的总结是否准确；" class="headerlink" title="八、理解Linux系统中进程调度的时机，可以在内核代码中搜索schedule()函数，看都是哪里调用了schedule()，判断我们课程内容中的总结是否准确；"></a>八、理解Linux系统中进程调度的时机，可以在内核代码中搜索schedule()函数，看都是哪里调用了schedule()，判断我们课程内容中的总结是否准确；</h3><p>调用地方：</p>
<ul>
<li>中断处理过程（包括时钟中断、I/O中断、系统调用和异常）中，直接调用schedule()，或者返回用户态时根据need_resched标记调用schedule()</li>
<li>内核线程可以直接调用schedule()进行进程切换，也可以在中断处理过程中进行调度，也就是说内核线程作为一类的特殊的进程可以主动调度，也可以被动调度；</li>
<li>用户态进程无法实现主动调度，仅能通过陷入内核态后的某个时机点进行调度，即在中断处理过程中进行调度。</li>
</ul>
<h3 id="九、使用gdb跟踪分析一个schedule-函数-，验证对Linux系统进程调度与进程切换过程的理解"><a href="#九、使用gdb跟踪分析一个schedule-函数-，验证对Linux系统进程调度与进程切换过程的理解" class="headerlink" title="九、使用gdb跟踪分析一个schedule()函数 ，验证对Linux系统进程调度与进程切换过程的理解"></a>九、使用gdb跟踪分析一个schedule()函数 ，验证对Linux系统进程调度与进程切换过程的理解</h3><p>首先设几个断点分别是schedule，pick_next_task，context_switch，__switch_to<br><img src="https://img-blog.csdnimg.cn/20190322211251630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>schdule调用和函数<br><img src="https://img-blog.csdnimg.cn/20190322211545516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190322211616457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>两个重要的函数context_switch和pick_next_task函数都在schedule函数中</p>
<p><img src="https://img-blog.csdnimg.cn/20190322211725727.png" alt="在这里插入图片描述"><br>pick_next_task<br><img src="https://img-blog.csdnimg.cn/20190322211754470.png" alt="在这里插入图片描述"></p>
<p>context_switch<br><img src="https://img-blog.csdnimg.cn/20190322211833992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM4OTA5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="十、分析switch-to中的汇编代码，理解进程上下文的切换机制，以及与中断上下文切换的关系"><a href="#十、分析switch-to中的汇编代码，理解进程上下文的切换机制，以及与中断上下文切换的关系" class="headerlink" title="十、分析switch_to中的汇编代码，理解进程上下文的切换机制，以及与中断上下文切换的关系"></a>十、分析switch_to中的汇编代码，理解进程上下文的切换机制，以及与中断上下文切换的关系</h3><p>1.关键函数的调用关系:</p>
<p>schedule() –&gt; context_switch() –&gt; switch_to –&gt; __switch_to()</p>
<p>2.汇编代码分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"pushfl\n\t"</span> <span class="comment">/* 保存当前进程的标志位 */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"pushl %%ebp\n\t"</span> <span class="comment">/* 保存当前进程的堆栈基址EBP */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"movl %%esp,%[prev_sp]\n\t"</span> <span class="comment">/* 保存当前栈顶ESP */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"movl %[next_sp],%%esp\n\t"</span> <span class="comment">/* 把下一个进程的栈顶放到esp寄存器中，完成了内核堆栈的切换，从此往下压栈都是在next进程的内核堆栈中。 */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"movl $1f,%[prev_ip]\n\t"</span> <span class="comment">/* 保存当前进程的EIP */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"pushl %[next_ip]\n\t"</span> <span class="comment">/* 把下一个进程的起点EIP压入堆栈 */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">             __switch_canary </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"jmp __switch_to\n"</span> <span class="comment">/* 因为是函数所以是jmp，通过寄存器传递参数，寄存器是prev-a，next-d，当函数执行结束ret时因为没有压栈当前eip，所以需要使用之前压栈的eip，就是pop出next_ip。 */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">             </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"1:\t"</span> <span class="comment">/* 认为next进程开始执行。 */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"popl %%ebp\n\t"</span> <span class="comment">/* restore EBP */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"popfl\n"</span> <span class="comment">/* restore flags */</span> <span class="comment">/* output parameters 因为处于中断上下文，在内核中 prev_sp是内核堆栈栈顶 prev_ip是当前进程的eip */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">             : [prev_sp] <span class="string">"=m"</span> (prev-&gt;thread.sp), </span></span></span><br><span class="line"><span class="function"><span class="params">             [prev_ip] <span class="string">"=m"</span> (prev-&gt;thread.ip), <span class="comment">//[prev_ip]是标号 </span></span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"=a"</span> (last), </span></span></span><br><span class="line"><span class="function"><span class="params">             </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="comment">/* clobbered output registers: */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"=b"</span> (ebx), <span class="string">"=c"</span> (ecx), <span class="string">"=d"</span> (edx), <span class="string">"=S"</span> (esi), <span class="string">"=D"</span> (edi) 			</span></span></span><br><span class="line"><span class="function"><span class="params">             __switch_canary_oparam </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="comment">/* input parameters: next_sp下一个进程的内核堆栈的栈顶 next_ip下一个进程执行的起点，一般是$1f，对于新创建的子进程是ret_from_fork*/</span> </span></span></span><br><span class="line"><span class="function"><span class="params">             : [next_sp] <span class="string">"m"</span> (next-&gt;thread.sp), </span></span></span><br><span class="line"><span class="function"><span class="params">             [next_ip] <span class="string">"m"</span> (next-&gt;thread.ip), </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="comment">/* regparm parameters for __switch_to(): */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">             [prev] <span class="string">"a"</span> (prev), </span></span></span><br><span class="line"><span class="function"><span class="params">             [next] <span class="string">"d"</span> (next) </span></span></span><br><span class="line"><span class="function"><span class="params">             </span></span></span><br><span class="line"><span class="function"><span class="params">             __switch_canary_iparam : <span class="comment">/* reloaded segment registers */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"memory"</span>)</span></span>; </span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>switch_to实现了进程之间的真正切换：</p>
<ul>
<li>首先在当前进程prev的内核栈中保存esi,edi及ebp寄存器的内容。</li>
<li>然后将prev的内核堆栈指针ebp存入prev-&gt;thread.esp中。</li>
<li>把将要运行进程next的内核栈指针next-&gt;thread.esp置入esp寄存器中</li>
<li>将popl指令所在的地址保存在prev-&gt;thread.eip中，这个地址就是prev下一次被调度</li>
<li>通过jmp指令（而不是call指令）转入一个函数__switch_to()</li>
<li>恢复next上次被调离时推进堆栈的内容。从现在开始，next进程就成为当前进程而真正开始执行</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对Linux系统的执行过程的理解：</p>
<ul>
<li>在调度时机方面，内核线程可以直接调用schedule()进行进程切换，也可以在中断处理过程中进行调度，也就是说内核线程作为一类的特殊的进程可以主动调度，也可以被动调度。</li>
<li>schedule()函数实现进程调度，context_ switch完成进程上下文切换，switch_ to完成寄存器的切换。</li>
<li>用户态进程无法实现主动调度，仅能通过陷入内核态后的某个时机点进行调度，即在中断处理过程中进行调度</li>
</ul>
<p>参考</p>
<p><a href="https://blog.csdn.net/weixin_43389097/article/details/88743522" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43389097/article/details/88743522</a></p>
<p><a href="https://blog.csdn.net/m0_37962600/article/details/79943461" target="_blank" rel="noopener">https://blog.csdn.net/m0_37962600/article/details/79943461</a></p>
<p><a href="https://blog.csdn.net/pjz000/article/details/88818849" target="_blank" rel="noopener">https://blog.csdn.net/pjz000/article/details/88818849</a></p>
<p><a href="https://blog.csdn.net/qq_31209133/article/details/88817974" target="_blank" rel="noopener">https://blog.csdn.net/qq_31209133/article/details/88817974</a></p>
<p><a href="https://blog.csdn.net/qq_30417071/article/details/88809270" target="_blank" rel="noopener">https://blog.csdn.net/qq_30417071/article/details/88809270</a></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/16/实验二-跟踪分析Linux内核5-0系统调用处理过程/" rel="next" title="实验二 跟踪分析Linux内核5.0系统调用处理过程">
                <i class="fa fa-chevron-left"></i> 实验二 跟踪分析Linux内核5.0系统调用处理过程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">PCM</p>
              <div class="site-description motion-element" itemprop="description">fighting</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、阅读理解task-struct数据结构"><span class="nav-number">1.</span> <span class="nav-text">一、阅读理解task_struct数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程"><span class="nav-number">1.0.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作系统"><span class="nav-number">1.0.2.</span> <span class="nav-text">操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程控制块PCB–task-struct"><span class="nav-number">1.0.3.</span> <span class="nav-text">进程控制块PCB–task_struct</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重要参数"><span class="nav-number">1.0.4.</span> <span class="nav-text">重要参数</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#二、分析fork函数对应的内核处理过程"><span class="nav-number">2.</span> <span class="nav-text">二、分析ｆｏｒｋ函数对应的内核处理过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三-使用GDB分析"><span class="nav-number">2.1.</span> <span class="nav-text">三.使用GDB分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、理解编译连接的过程和ELF可执行文件格式"><span class="nav-number">2.2.</span> <span class="nav-text">四、理解编译连接的过程和ELF可执行文件格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、编程使用exec-库函数加载一个可执行文件，动态链接分为可执行程序装载时动态链接和运行时动态链接"><span class="nav-number">2.3.</span> <span class="nav-text">五、编程使用exec*库函数加载一个可执行文件，动态链接分为可执行程序装载时动态链接和运行时动态链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六、使用gdb跟踪分析一个execve系统调用内核处理函数do-execve-验证您对linux系统加载可执行程序所需过程的理解"><span class="nav-number">2.4.</span> <span class="nav-text">六、使用gdb跟踪分析一个execve系统调用内核处理函数do_execve,验证您对linux系统加载可执行程序所需过程的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七、特别关注新的可执行程序是从哪里开始执行的？为什么execve系统调用返回后新的可执行程序能顺利执行？对于静态链接的可执行程序和动态链接的可执行程序execve系统调用返回时会有什么不同？"><span class="nav-number">2.5.</span> <span class="nav-text">七、特别关注新的可执行程序是从哪里开始执行的？为什么execve系统调用返回后新的可执行程序能顺利执行？对于静态链接的可执行程序和动态链接的可执行程序execve系统调用返回时会有什么不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八、理解Linux系统中进程调度的时机，可以在内核代码中搜索schedule-函数，看都是哪里调用了schedule-，判断我们课程内容中的总结是否准确；"><span class="nav-number">2.6.</span> <span class="nav-text">八、理解Linux系统中进程调度的时机，可以在内核代码中搜索schedule()函数，看都是哪里调用了schedule()，判断我们课程内容中的总结是否准确；</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九、使用gdb跟踪分析一个schedule-函数-，验证对Linux系统进程调度与进程切换过程的理解"><span class="nav-number">2.7.</span> <span class="nav-text">九、使用gdb跟踪分析一个schedule()函数 ，验证对Linux系统进程调度与进程切换过程的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十、分析switch-to中的汇编代码，理解进程上下文的切换机制，以及与中断上下文切换的关系"><span class="nav-number">2.8.</span> <span class="nav-text">十、分析switch_to中的汇编代码，理解进程上下文的切换机制，以及与中断上下文切换的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">2.9.</span> <span class="nav-text">总结</span></a></li></ol></li></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PCM</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.1"></script>



  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
